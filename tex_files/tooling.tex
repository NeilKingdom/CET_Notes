\documentclass{article}

\usepackage{titling}
\usepackage{geometry}
\usepackage{fontspec}
\usepackage{color}
\usepackage{xcolor} 
\usepackage{tcolorbox}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage[outputdir=/home/neil/.local/share/latex/output]{minted}

\definecolor{inline}{RGB}{187,57,82}
\definecolor{bg}{RGB}{22,43,58}

\tcbuselibrary{listings, minted, skins}
\tcbset{listing engine=minted}
\newtcblisting{rustlst}{%
   listing only, 
   minted language=rust, 
   minted style=material,
   colback=bg, 
   enhanced, 
   frame hidden, 
   minted options={%
      tabsize=4, 
      breaklines, 
      autogobble
   }
}

\hypersetup{%
   colorlinks=true, 
   linktoc=all,    
   linkcolor=gray, 
}

\setmainfont{LiberationSans}
\geometry{%
  margin=1in
}

\fancyhf{}
\renewcommand{\headrulewidth}{0pt}
\fancyfoot[R]{\thepage}
\pagestyle{fancy}
\fancypagestyle{plain}{\pagestyle{fancy}}

\renewcommand\maketitlehooka{\null\mbox{}\vfill}
\renewcommand\maketitlehookd{\vfill\null}

\title{Tooling}
\author{Neil Kingdom}

\begin{document}

\begin{titlingpage}

\maketitle

\end{titlingpage}

\newpage

\tableofcontents

\newpage

\section{Preface}

\section{Introduction}

I would argue that understanding the syntax and APIs of a language is only half the battle towards becoming 
a valuable developer. This is because programming is more than just understanding syntax and memorization. It 
also requires being able to leverage your own productivity. Developers are expected to learn many tools which 
can be beneficial for increasing productivity and which can aid in minimizing complexity. In this document, I 
will be focusing on three tools which I use on a regular basis and which I think are worthwhile additions to 
your arsenal. These three tools are git, make (as in Makefile), and GDB. If I could add a fourth, it would 
certainly be vim/neovim, however, vim is a very complex beast that is best learned through consistent usage. 
This list is, of course, heavily biased towards the work that I do, but even if you do not end up using any of 
these tools, it is still extremely beneficial to your growth to sit down and learn a new tool. 

\section{Git}

I'll begin with arguably the most difficult, but also most widely used tool of the bunch. This would of course 
be Git. I'm sure you've heard of Git, but if not, I'll elaborate. Git is a version control system (VCS) written 
by Linus Torvalds (the same guy who made Linux) in 2008. Its predecessors include Subversion (SVN) and TFS. A 
VCS has multiple practical usages, but true to its name, it is predominantly used for tracking changes 
(or versions) over time. Git keeps a robust log of diffs known as the branch history. A diff is just a file 
that highlights changes since the previous version i.e. additions, removals, or modifications. One of the 
greatest features of Git is that it makes collaborative projects much easier since it will prevent two people 
from accidentally making conflicting changes. Instead, it forces both parties to resolve the conflicts before 
the repository is actually updated.\\ 

There is a big distinction to be made between Git (a command) and GitHub (a service hosted in the cloud which 
stores Git repositories remotely). Git is local to the user's machine, meaning that everything is tracked 
locally by default. GitHub is often the defacto choice for a remote Git client, however, others exist such as 
GitLab, BitBucket, SourceForge, and GNU's Savannah. I won't argue for which of these you ought to use, although 
I will say that latter two options are not mainstream choices.\\

Personally, I use GitHub almost exclusively to backup my personal projects and sometimes even other kinds of 
files. They offer a generous amount of storage space (I'm not even sure if there is a limit to be honest) 
completely for free! 

\subsection{Understanding Git}

Git is actually quite difficult to learn, and even harder to master. It really does require a bit of theory 
and practice before you're able to get comfortable. Although many IDEs include visualization tools for Git, I 
highly recommend learning the command line tool instead.\\

First, I'll cover a bit of semantics. A repository is the logical collection of files that are to be tracked 
by Git. For all intents and purposes, this usually equates to your project's directory. Git does have support 
for submodules which are essentially just a way of nesting repositories within other repositories, but I'll 
cover that much later. Anyhow, all of the metadata used to track the repos history is stored within the .git 
directory. It is generally a good idea to not touch anything in here at the risk of severely messing up your 
project.\\

In order to create the .git directory i.e. setup the repo, we simply navigate to the root of the 
project or whatever it is you want to track and run git init. Assuming that files exist in the repo, we can 
try running git status. This subcommand will output some useful information. It will first state that we're on 
the main branch. One of the most interesting features of Git is its ability to switch between branches, which 
are effectively diverging histories. Think of it like a multiverse of project histories that we can switch 
between. You can try implementing a change in one branch and then revert back to the previous branch to reset 
the project's internal state back to how it was on that branch. The default branch used to be called master but 
is now called main for political reasons. You can change this within Git's config files. Another piece of 
information output by Git is that there have not been any commits yet. A commit can be thought of as a 
checkpoint marking a significant set of changes or milestone within the change history. If you've ever dabbled 
with emulators, I like to think of commits as a save-state because we can jump between different commits. 
Assuming that there are files within your repo, you should also have a log indicating that there are one or 
more untracked files. Git does not keep track of any files by default, therefore, we have to opt in to which 
ones it should track. Git will propose that we use git add to track a file. In many cases, we just want to 
track all files, which can be done by running "git add .". The period is similar to the kleane/wildcard 
operator.\\

When we add files to be tracked by Git, they are queued into what is referred to as the staging area. The 
staging area simply contains files which are ready to be committed. Running git status again after we've 
added one or more files to be staged will yield a similar output, but now it should show all of the staged 
files under changes to be committed. It will also suggest running git rm --cached to remove a tracked/staged
file. Never run git rm -f unless you want to actually delete the file from disk. If you remove a file with 
the regular rm command, it doesn't automatically make git forget about it, so you'll still have to run 
git rm --cached file.\\

It is at this time that I should point out to you that most of the commonly used subcommands can be found by 
just running the git command by itself. Running git <subcommand> -h will provide the flags or further 
subcommands for the subcommand specified. For instance running git add -h will reveal all of the flags that 
can be applied to the add subcommand. 

\subsection{Making Our First Commit}

Let's make history by committing a change! Assuming you've added one or more files to be tracked, we now need 
to actually modify one. Make any modification to any one of the tracked files e.g. adding a line of text. 
Even though you might think that git add would be a one time deal, it's actually not. When a modification is 
made to a file, we actually have to re-add the updated changes before committing. Running git status will 
tell us that we can either run git add to update what will be committed, or git restore to discard the changes 
we made to the file. I don't typically use git restore due to how it's pretty easy to accidentally restore a 
file you didn't mean to restore. Anyhow, run git add <file> or git add . to update the file in staging. Now 
we will run git commit -m "Initial commit". The git commit subcommand will open up nano by default if the -m 
flag is not set. This is a pretty easy thing for beginners to forget, but that you'll quickly grow out of 
after getting sick of always opening up nano. The -m flag stands for message, because every commit must have 
an associated commit message. Initial commit is sort of like the hello world of programming - it's just a 
standard message to use for your first commit. Subsequent commits should be concise but detailed and pertain 
to the change(s) that were made. And with that, we now have our first commit! There are a few interesting 
things that we can do now that we've made at least one commit. Let's first run git log. This will show the 
commit log with a list of every commit that Git has tracked. Every commit has a 40 character hash which is 
used as a unique identifier. For simplicity's sake, the authors of Git made it so that all of the subcommands 
which require a commit hash can optionally take just the first 7 characters of the hash. Running git log with 
the --oneline option will output a reduced/less verbose commit log with the abbreviated hash and the author and 
date information stripped while retaining the commit message. I'll explain in a moment what the (HEAD -> main) 
means.\\

Another neat subcommand we can now utilize is git diff. The git diff subcommand will by default list every diff 
for every file that was changed between the current commit and the previous commit (or in our case since the 
repo was initialized). We can optionally specify a particular file to perform the diff on e.g. git diff [file].
We can also optionally specify the precise commit hashes that we want to use for the comparison. For example: 
git diff e69de29..92508ea file. These are the abbreviated hashes I mentioned before which can be obtained with 
git log --oneline. An easier way, however, is to use 

\end{document}
